esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf

# Enable logging
logger:
  baud_rate: 0
  level: WARN
#  logs:
#    api.service: WARN
#    sensor: WARN
#    homeassistant.sensor: WARN
#    text_sensor: WARN
#    jk_bms_ble: WARN
#    soyosource_display: WARN
#    soyosource_virtual_meter: WARN
#    ads1115: WARN

# Enable Home Assistant API
api:
  password: ""
  reboot_timeout: 24h

ota:
  password: ""
  on_begin:
    then:
      - logger.log: "OTA start, disabling BMS bluetooth."
      - switch.turn_off: ble_jk

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_pw
  manual_ip:
    static_ip: 192.168.1.20
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 192.168.1.25

time:
  - platform: sntp
    #move time zone by 6 hours, so daily_energy monitors are reset at 07:00 (used in fallback_powermeter to decide if the battery should be emptied over night)
    timezone: CET+6CEST,M3.5.0,M10.5.0/3

esphome:
  name: garage-controller
  comment: "ESP32 in der Garage"
  project:
    name: "garage.controller"
    version: 1.0.0
  includes:
    - protect_battery.h
preferences:
  flash_write_interval: 10min

globals:
  - id: api_connection
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: max_demand
    type: int 
    restore_value: no
    initial_value: '920'
  - id: protect_battery
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: soyoUpdC
    type: short
    restore_value: no
    initial_value: '0'
  - id: operationMode
    type: short
    restore_value: no
    initial_value: '0'

interval:
  - interval: 5s
    startup_delay: 1s
    then:
      - if:
          condition:
            # check last connection state
            - lambda: 'return { (id(api_connection) != true) };'
          then:
            - if:
                condition:
                  api.connected:
                then:
                  # just connected now
                  - lambda: "id(api_connection) = true;"
          else:
            - if:
                condition:
                  not:
                    api.connected:
                then:
                  # just disconnected now
                  - lambda: "id(api_connection) = false;"

      - lambda: |-

          if (id(protect_battery)) {
            id(operationMode) = 0; //PV in -> Soyo out
            
            return;
          }

          if (!id(api_connection)) {
            //goal: Only use solar power, 0W to or from battery. Disable below 50W because of bad efficency.
            id(operationMode) = 1;
            return;
          }


          if (id(batt_voltage_avg).state > 47.5 || id(solar_energy_today).state >= 4) {
            //use powermeter for demand
            id(operationMode) = 3;
          } else {
            //PV -> demand, but charge when PV > power consumption
            id(operationMode) = 2;
          }

      - lambda: |-

          if (id(operationMode) == 0 || id(operationMode) == 1) {
            auto prevLatency = id(soyo_latency).state;
            if (prevLatency > 3000) {
              auto l = id(soyo_latency).make_call();
              l.set_value(2050);
              l.perform();
            }

            if (id(operationMode) == 0) {
              auto b = id(soyo_buffer).make_call();
              b.set_value(1);
              b.perform();
            }
          }
          else {
            auto prevLatency = id(soyo_latency).state;
            if (prevLatency < 3000) {
              auto l = id(soyo_latency).make_call();
              l.set_value(4550);
              l.perform();
            }
          }

      - lambda: |-
          if (id(soyo_operation_mode).state == "PV") {
            id(max_demand) = 1120;
          } else {
            id(max_demand) = 920;
          }

          int md = id(soyo_max_demand).state;

          if ((md == 920.0 || md == 1120.0) && md != id(max_demand)) {
            auto numberF = id(soyo_max_demand).make_call();
            numberF.set_value(id(max_demand));
            numberF.perform();
          }


  - interval: 100s
    startup_delay: 5s
    then:
      - if:
          condition:
            - lambda: "return { id(soyo_output_limit).state != 900.0 };"
          then:
            - number.set:
                id: soyo_output_limit
                value: 900
      - if:
          condition:
            - lambda: "return { id(soyo_start_delay).state != 3.0 };"
          then:
            - number.set:
                id: soyo_start_delay
                value: 3
      - if:
          condition:
            - lambda: "return { id(soyo_operation_mode).state == \"Battery Constant Power\" };"
          then:
            - select.set:
                id: soyo_operation_select
                option: "Battery Limit"

  - interval: 45s
    startup_delay: 1s
    then:
      - switch.turn_on: ntc_vcc
      - component.update: adc1
      - component.update: adc2
      - switch.turn_off: ntc_vcc

      - lambda: |-
          //checkTmp is from protect_battery.h

          if (checkTmp(id(batt_temp1).state) || checkTmp(id(batt_temp2).state) || checkTmp(id(batt_temp3).state) || checkTmp(id(batt_temp4).state)) {
            id(protect_battery) = true;
            ESP_LOGW("interval", "Battery Protection enabled!"); 
          }
          else {
            id(protect_battery) = false;
            ESP_LOGI("interval", "Battery Protection disabled!");
          }


  - interval: 50ms
    startup_delay: 50ms
    then:
      - component.update: mpptSensor
      - component.update: soyoSensor
      - lambda: |-
          if(id(soyoUpdC) >= 4) {
            id(powermeter_with_fallback).update();
            id(soyoUpdC) = 0;
          }
          else {
            id(soyoUpdC)++;
          }

substitutions:
  name: jk-bms
  device_description: "Monitor and control a JK-BMS via bluetooth"
  external_components_source_jk: github://syssi/esphome-jk-bms@main
  mac_address: C8:47:8C:E9:44:3F
  protocol_version: JK02_32S

  name_soyo: soyo
  device_description_soyo: "Soyosource GTN control the power output on demand both via RS485"
  external_components_source_soyo: github://syssi/esphome-soyosource-gtn-virtual-meter@main


external_components:
  - source: ${external_components_source_jk}
    refresh: 0s
  - source: github://kev300/esphome-soyosource-gtn-virtual-meter@overshoot_compensation
    refresh: 0s
      #- source: ${external_components_source_soyo}
      #refresh: 7d


esp32_ble_tracker:
  scan_parameters:
    interval: 500ms
  on_ble_advertise:
    then:
      - lambda: |-
          if (x.get_name().rfind("JK-", 0) == 0) {
            ESP_LOGI("ble_adv", "New JK-BMS found");
            ESP_LOGI("ble_adv", "  Name: %s", x.get_name().c_str());
            ESP_LOGI("ble_adv", "  MAC address: %s", x.address_str().c_str());
            ESP_LOGD("ble_adv", "  Advertised service UUIDs:");
            for (auto uuid : x.get_service_uuids()) {
              ESP_LOGD("ble_adv", "    - %s", uuid.to_string().c_str());
            }
          }

ble_client:
  - mac_address: ${mac_address}
    id: client0

jk_bms_ble:
  - ble_client_id: client0
    protocol_version: ${protocol_version}
    throttle: 5s
    id: bms0

i2c:
  sda: GPIO14
  scl: GPIO27
  scan: true

ads1115:
  - address: 0x4A

uart:
  #- id: uart0
  #  baud_rate: 115200
  #  rx_buffer_size: 384
  #  tx_pin: ${tx_pin}
  #  rx_pin: ${rx_pin}

  - id: uart_powerd
    baud_rate: 4800
    tx_pin: GPIO18
    rx_pin: GPIO19
  - id: uart_display
    baud_rate: 9600
    tx_pin: GPIO16
    rx_pin: GPIO17

soyosource_modbus:
  - id: modbus1
    uart_id: uart_powerd

    # Optional settings
    #
    # The name is used as prefix for some log messages and should
    # help to distinguish between different instances/devices
    name: garage_inverter

soyosource_virtual_meter:
  - id: virtualmeter0
    soyosource_modbus_id: modbus1

    # The state of this sensor (instantaneous power in watt) is used as source
    power_id: powermeter_with_fallback

    # Optional settings
    power_sensor_inactivity_timeout: 20s
    power_demand_calculation: NEGATIVE_MEASUREMENTS_REQUIRED
    min_power_demand: 0
    max_power_demand: 1120
    # Split/distribute the power demand if you have multiple inverters attached to the same RS485 bus
    power_demand_divider: 1
    # A positive buffer value (10) tries to avoid exporting power to the grid (demand - 10 watts)
    # A negative buffer value (-10) exports power to the grid (demand + 10 watts)
    buffer: 0
    zero_output_on_min_power_demand: true
    max_power_sensor_latency_ms: 5000 

    # The operation_status_id sensor is expected here. Passing the operation_status won't work
    # The state is used to suspend the limiter if the operation status of the inverter isn't 0x0 (normal)
    # operation_status_id: operation_status_id0
    update_interval: never

soyosource_display:
  - id: soyo_display
    uart_id: uart_display
    protocol_version: SOYOSOURCE_DISPLAY_VERSION
    update_interval: 5s


binary_sensor:
  - platform: jk_bms_ble
    balancing:
      name: "${name} balancing"
    online_status:
      name: "${name} online status"
  - platform: soyosource_display
    limiter_connected:
      name: "${name_soyo} limiter connected"

button:
  - platform: soyosource_display
    restart:
      name: "${name_soyo} restart"
  - platform: jk_bms_ble
    retrieve_settings:
      name: "${name} retrieve settings"
    retrieve_device_info:
      name: "${name} retrieve device info"


number:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    manual_power_demand:
      name: "${name_soyo} manual power demand"
      max_value: 1300
    max_power_demand:
      name: "${name_soyo} max power demand"
      id: soyo_max_demand
      initial_value: 920
      max_value: 1120
      restore_value: false
    buffer:
      name: "${name_soyo} buffer"
      id: soyo_buffer
      initial_value: 0
      restore_value: true
    max_power_sensor_latency_ms:
      name: "${name_soyo} sensor_latency"
      id: soyo_latency
      initial_value: 5000
      restore_value: false

  - platform: soyosource_display
    start_voltage:
      name: "${name_soyo} start voltage"
    shutdown_voltage:
      name: "${name_soyo} shutdown voltage"
    # Maximum output power in limiter mode / Output power in constant power mode
    output_power_limit:
      name: "${name_soyo} output power limit"
      id: soyo_output_limit
    start_delay:
      name: "${name_soyo} start delay"
      id: soyo_start_delay

  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    balance_trigger_voltage:
      name: "${name} balance trigger voltage"
    total_battery_capacity:
      name: "${name} total battery capacity"
    cell_voltage_overvoltage_protection:
      name: "${name} cell voltage overvoltage protection"
    cell_voltage_overvoltage_recovery:
      name: "${name} cell voltage overvoltage recovery"
    cell_voltage_undervoltage_protection:
      name: "${name} cell voltage undervoltage protection"
    cell_voltage_undervoltage_recovery:
      name: "${name} cell voltage undervoltage recovery"
    balance_starting_voltage:
      name: "${name} balance starting voltage"
    power_off_voltage:
      name: "${name} power off voltage"
    max_balance_current:
      name: "${name} max balance current"
    max_charge_current:
      name: "${name} max charge current"
    max_discharge_current:
      name: "${name} max discharge current"

select:
  - platform: soyosource_display
    operation_mode:
      name: "${name_soyo} operation mode"
      id: soyo_operation_select
      optionsmap:
        1: "PV"
        2: "Battery Constant Power"
        16: "Battery Limit"

#debug:
#  update_interval: 5s

sensor:
  #  - platform: debug
  #    free:
  #      name: "Heap Free"
  #    block:
  #      name: "Heap Max Block"
  #    loop_time:
  #      name: "Loop Time"

  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal %"
    update_interval: 120s
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: "diagnostic"

  - platform: dht
    pin: GPIO26
    temperature:
      name: "Garage Temperatur"
      id: garage_temp
    humidity:
      name: "Garage Feuchtigkeit"
      id: garage_humid
    update_interval: 120s

  - platform: ina226
    address: 0x40
    update_interval: never
    id: soyoSensor
    shunt_resistance: 0.0015 ohm
    max_current: 50A
    current:
      #name: "Inverter amps"
      id: inverter_amps
      filters:
        - exponential_moving_average:
           send_every: 5
           alpha: 0.079
        - offset: 0.001526
      on_value:
        then:
          - component.update: soyo_power
    bus_voltage:
      id: pv_voltage
      filters:
        - exponential_moving_average:
           send_every: 10
        - calibrate_linear:
          - 0.0 -> 0.0
          - 16.98 -> 53.47

  - platform: ina226
    address: 0x41
    shunt_resistance: 0.0015 ohm
    max_current: 50A
    update_interval: never
    id: mpptSensor
    current:
      id: charging_amps
      #name: cargingAmps
      filters:
        - exponential_moving_average:
           send_every: 5
        - multiply: -1
      on_value:
        then:
          - component.update: solar_power_only
    bus_voltage:
      id: batt_voltage
      #name: bvv
      filters:
        - exponential_moving_average:
           send_every: 5
        - calibrate_linear:
          - 0.0 -> 0.0
          - 23.46 -> 47.04
      on_value_range:
        - above: 53.4
          then:
            - number.set:
                id: soyo_buffer
                value: -80
        - below: 53
          then:
            - number.set:
                id: soyo_buffer
                value: -2
        - above: 44.7
          then:
            - number.set:
                id: soyo_max_demand
                value: !lambda |-
                  return id(max_demand);
        - below: 44
          then:
            - number.set:
                id: soyo_max_demand
                value: 200


# import smartmeter reading from homeassistant
#   # requires the "api" component see above
  - platform: homeassistant
    id: powermeter0
    entity_id: sensor.power_consumption
    filters:
      - lambda: if (x < -800) return -800; return x; #sometimes the meter reports very low values!? + slow down ramp down

  - platform: template
    id: powermeter_with_fallback
    update_interval: never
    internal: true
    unit_of_measurement: W
    lambda: |-

      switch (id(operationMode)) {
        case 0:
          //protect battery, no charging

          if (id(solar_power_only).raw_state > 7) {
            return id(solar_power_only).raw_state - id(soyo_power).raw_state;
          }
          else {
            return -1;
          }

        case 1:
          //no api connection, only solar above 60W, else charging

          if (id(solar_power_only).raw_state > 60) {
            return id(solar_power_only).raw_state - id(soyo_power).raw_state;
          }
          else {
            return id(soyo_buffer).state -65; //get's to 0W demand slowly
          }

        case 2:
          if (id(solar_power_only).raw_state > 60) {
            auto solar_demand = id(solar_power_only).raw_state - id(soyo_power).raw_state;

            if (solar_demand > id(powermeter0).state) {
              return id(powermeter0).state;
            }
            else {
              return solar_demand;
            }

          }
          else {
            return id(soyo_buffer).state -65; //get's to 0W demand slowly
          }

        case 3:
          return id(powermeter0).state;
        case 4:
          return -100; //off / only charging
      }

      //default
      return id(solar_power_only).raw_state - id(soyo_power).raw_state;



  - platform: template
    id: soyo_power
    name: "soyo power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    lambda: |-
      return id(batt_voltage).state * id(inverter_amps).state;
    update_interval: never
    filters:
      - throttle_average: 5s

  - platform: template
    id: solar_power_only
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    lambda: |-
      return (isnan(id(batt_voltage).state) ? 0 : id(batt_voltage).state) * id(charging_amps).state;
    update_interval: never #updated by batt_voltage
    on_value:
      then:
        - component.update: charging_power
        - component.update: discharging_power
        - component.update: solar_power_positive

  - platform: template
    id: solar_power_positive
    lambda: return id(solar_power_only).state;
    filters:
      - clamp:
          min_value: 0
    update_interval: never

  - platform: template
    id: charging_power
    unit_of_measurement: W
    lambda: |-
      auto w = id(solar_power_only).raw_state - id(soyo_power).raw_state;
      return w < 0 ? 0 : w;
    update_interval: never

  - platform: template
    id: discharging_power
    unit_of_measurement: W
    lambda: |-
       auto w = id(soyo_power).raw_state - id(solar_power_only).raw_state;
       return w < 0 ? 0 : w;
    update_interval: never

  - platform: template
    id: batt_voltage_avg
    update_interval: 60s
    lambda: return id(batt_voltage).state;
    filters:
      - sliding_window_moving_average:
          window_size: 16
          send_every: 6

# throttled for HA:
  - platform: template
    name: "Garage System Power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 5s
    lambda: return id(solar_power_only).raw_state - id(soyo_power).raw_state;

  - platform: template
    name: "solarstrom power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    entity_category: diagnostic
    accuracy_decimals: 2
    icon: mdi:solar-power-variant
    lambda: return id(solar_power_only).state;
    update_interval: 1s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

  - platform: template
    name: "Batt Volt"
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    lambda: return id(batt_voltage).state;
    update_interval: 1s
    filters:
      - sliding_window_moving_average:
          window_size: 7
          send_every: 7

  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    power_demand:
      name: "${name_soyo} power demand"
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      entity_category: diagnostic

  - platform: total_daily_energy
    name: "${name} charging energy today"
    icon: mdi:counter
    power_id: charging_power
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - multiply: 0.001
      - throttle: 120s

  - platform: total_daily_energy
    name: "${name} discharging energy today"
    icon: mdi:counter
    power_id: discharging_power
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - multiply: 0.001
      - throttle: 120s

  - platform: total_daily_energy
    name: "solarstrom energy"
    id: solar_energy_today
    icon: mdi:counter
    power_id: solar_power_positive
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - multiply: 0.001
      - throttle: 120s

  - platform: ads1115
    multiplexer: 'A0_GND'
    gain: 4.096
    id: adc1
    update_interval: never

  - platform: ads1115
    multiplexer: 'A1_GND'
    gain: 4.096
    id: adc2
    update_interval: never

  - platform: resistance
    id: resistance_sensor_1
    sensor: adc1
    configuration: DOWNSTREAM
    resistor: 5.75kOhm
    reference_voltage: 3.2V
  - platform: resistance
    id: resistance_sensor_2
    sensor: adc2
    configuration: DOWNSTREAM
    resistor: 5.75kOhm
    reference_voltage: 3.2V

  - platform: ntc
    sensor: resistance_sensor_1
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    name: "Batt Temp 3"
    id: batt_temp3
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 2
  - platform: ntc
    sensor: resistance_sensor_2
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    name: "Batt Temp 4"
    id: batt_temp4
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 2


  - platform: soyosource_display
    error_bitmask:
      name: "${name_soyo} error bitmask"
#    operation_status_id:
#      name: "${name_soyo} operation status id"
#      id: operation_status_id0
    battery_voltage:
      name: "${name_soyo} battery voltage"
      id: soyo_batt_voltage
      filters:
        - throttle: 10s
    battery_current:
      name: "${name_soyo} battery current"
      id: soyo_batt_current
      filters:
        - throttle: 10s
        - multiply: 0.933 #calibrate too high values
    battery_power:
      name: "${name_soyo} battery power"
      filters:
        - throttle: 10s
    ac_voltage:
      name: "${name_soyo} ac voltage"
      filters:
        - throttle: 30s
    ac_frequency:
      name: "${name_soyo} ac frequency"
      filters:
        - throttle: 120s
    temperature:
      name: "${name_soyo} temperature"
      filters:
        - throttle: 30s
  
  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    power:
      name: "${name} power"
      id: "jk_bms_power"
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      entity_category: diagnostic
      filters:
        - throttle_average: 10s

    min_cell_voltage:
      name: "${name} min cell voltage"
      filters:
      - throttle: 10s
    max_cell_voltage:
      name: "${name} max cell voltage"
      filters:
      - throttle: 10s
    min_voltage_cell:
      name: "${name} min voltage cell"
      filters:
      - throttle: 10s
    max_voltage_cell:
      name: "${name} max voltage cell"
      filters:
      - throttle: 10s
    delta_cell_voltage:
      name: "${name} delta cell voltage"
      filters:
      - throttle: 10s
    average_cell_voltage:
      name: "${name} average cell voltage"
      filters:
      - throttle: 10s
    cell_voltage_1:
      name: "${name} cell voltage 1"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_2:
      name: "${name} cell voltage 2"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_3:
      name: "${name} cell voltage 3"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_4:
      name: "${name} cell voltage 4"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_5:
      name: "${name} cell voltage 5"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_6:
      name: "${name} cell voltage 6"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_7:
      name: "${name} cell voltage 7"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_8:
      name: "${name} cell voltage 8"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_9:
      name: "${name} cell voltage 9"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_10:
      name: "${name} cell voltage 10"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_11:
      name: "${name} cell voltage 11"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_12:
      name: "${name} cell voltage 12"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_13:
      name: "${name} cell voltage 13"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    power_tube_temperature:
      name: "${name} BMS temperature"
      filters:
      - throttle: 10s
    temperature_sensor_1:
      id: batt_temp1
      name: "${name} temperature sensor 1"
      filters:
      - throttle: 10s
    temperature_sensor_2:
      id: batt_temp2
      name: "${name} temperature sensor 2"
      filters:
      - throttle: 10s
    total_voltage:
      name: "${name} total voltage"
      id: jk_bms_total_voltage
      filters:
        - throttle: 10s
    current:
      name: "${name} current"
      filters:
        - throttle: 10s
    charging_cycles:
      name: "${name} charging cycles"
      filters:
        - throttle: 120s
    errors_bitmask:
      name: "${name} errors bitmask"
    state_of_charge:
      name: "${name} state of charge"
    balancing_current:
      name: "${name} balancing current"
      filters:
      - throttle: 5s

switch:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    manual_mode:
      name: "${name_soyo} manual mode"
      restore_mode: RESTORE_DEFAULT_ON
    emergency_power_off:
      name: "${name_soyo} emergency power off"
      restore_mode: RESTORE_DEFAULT_OFF

  - platform: gpio
    pin: GPIO22
    name: "Garage lüften"
    id: garage_tilt_switch
    inverted: true 
    restore_mode: ALWAYS_OFF
    interlock: [garage_toggle_switch]
    on_turn_on:
    - delay: 200ms
    - switch.turn_off: garage_tilt_switch
    - delay: 500ms

  - platform: gpio
    pin: GPIO23
    name: "Garagentor auf/zu"
    id: garage_toggle_switch
    inverted: true
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [garage_tilt_switch]
    on_turn_on:
    - delay: 200ms
    - switch.turn_off: garage_toggle_switch
    - delay: 500ms

  - platform: gpio
    pin: GPIO13
    id: ntc_vcc
    internal: true

  - platform: jk_bms_ble
    charging:
      name: "${name} charging"
    discharging:
      name: "${name} discharging"
    balancer:
      name: "${name} balancer"

  - platform: ble_client
    ble_client_id: client0
    id: ble_jk
    name: "${name} enable bluetooth connection"

  - platform: restart
    name: "reboot"

cover:
  - platform: template
    name: "Garagentor"
    open_action:
      - switch.turn_on: garage_toggle_switch
    close_action:
      - switch.turn_on: garage_toggle_switch
    stop_action:
      - switch.turn_on: garage_toggle_switch
    optimistic: true
    assumed_state: true

text_sensor:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    operation_mode:
      name: "${name_soyo} limiter operation mode"
  - platform: soyosource_display
    errors:
      name: "${name_soyo} errors"
    operation_mode:
      name: "${name_soyo} operation mode"
      id: soyo_operation_mode
    operation_status:
      name: "${name_soyo} operation status"

  - platform: jk_bms_ble
    errors:
      name: "${name} errors"
    total_runtime_formatted:
      name: "${name} total runtime formatted"
        #  - platform: debug
        #    device:
        #      name: "Device Info"
        #    reset_reason:
        #      name: "Reset Reason"
#  - platform: ble_scanner
#    name: "BLE Devices Scanner"
