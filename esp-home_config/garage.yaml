esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf
    #sdkconfig_options:
    #  CONFIG_ESP32_DEFAULT_CPU_FREQ_240: "y"
    #  CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: "240"

# Enable logging
logger:
  baud_rate: 0
  level: INFO
  logs:
#    api.service: WARN
#    sensor: WARN
#    homeassistant.sensor: WARN
#    text_sensor: WARN
    jk_bms_ble: WARN
    soyosource_display: WARN
#    soyosource_virtual_meter: WARN
#    ads1115: WARN

# Enable Home Assistant API
api:
  password: ""
  reboot_timeout: 2h

ota:
  platform: esphome
  password: ""
  on_begin:
    then:
      - logger.log: "OTA start, disabling BMS bluetooth."
      - switch.turn_off: ble_jk

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_pw
  manual_ip:
    static_ip: 192.168.1.20
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 192.168.1.1

time:
  - platform: sntp
    #move time zone by 6 hours, so daily_energy monitors are reset at 07:00 (used in fallback_powermeter to decide if the battery should be emptied over night)
    timezone: CET+6CEST,M3.5.0,M10.5.0/3

esphome:
  name: garage-controller
  comment: "ESP32 in der Garage"
  includes:
    - clk.h
#  platformio_options:
#    board_build.f_cpu: 240000000L
  project:
    name: "garage.controller"
    version: 1.0.0
  on_boot:
    priority: 400
    then:
      - switch.turn_off: ble_jk

preferences:
  flash_write_interval: 20min


substitutions:
  name: jk-bms
  device_description: "Monitor and control a JK-BMS via bluetooth"
  external_components_source_jk: github://syssi/esphome-jk-bms@main
  mac_address: C8:47:8C:E9:44:3F
  protocol_version: JK02_32S

  name_soyo: soyo
  device_description_soyo: "Soyosource GTN control the power output on demand both via RS485"
  #external_components_source_soyo: github://syssi/esphome-soyosource-gtn-virtual-meter@main
  external_components_source_soyo: github://kev300/esphome-soyosource-gtn-virtual-meter@main

  maxBattVoltage: "53.3"

  #GPIO
  #  H = High; L = Low (voltage / signal) when active
  
  #Left Side
  pinNtcVccH: GPIO13
  pinSda: GPIO14
  
  pinDHT: GPIO26
  pinScl: GPIO27
  
  pinGarageClosedL: GPIO34
  pinGarageOpenedH: GPIO35
  
  #Right Side
  pinSoyoDispTx: GPIO04
  pinSoyoDispRx: GPIO16
  pinSoyoTx: GPIO18
  pinSoyoRx: GPIO19
  
  pinGarageTiltL: GPIO22
  pinGarageToggleL: GPIO23

  pinBattFan: GPIO01
  pinMpptCtrl: GPIO17
  pinBattHeater: GPIO21   
  
  
external_components:
  - source: ${external_components_source_jk}
    refresh: 0s
  - source: ${external_components_source_soyo}
    refresh: 0s
  - source: github://kev300/esphome@integration_with_setValue
    components: [ integration ]

globals:
  - id: api_connection
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: max_demand
    type: int 
    restore_value: no
    initial_value: '920'
  - id: operationMode
    type: short
    restore_value: no
    initial_value: '0'
  - id: maxChargeW
    type: short
    restore_value: no
    initial_value: '0'
  - id: maxChargeWReduction
    type: short
    restore_value: no
    initial_value: '0'
  - id: garageDoorState
    type: short
    initial_value: '-1'
    restore_value: no

interval:
  - interval: 5s
    startup_delay: 5s
    then:
      - if:
          condition:
            # check last connection state
            - lambda: 'return { (id(api_connection) != true) };'
          then:
            - if:
                condition:
                  api.connected:
                then:
                  # just connected now
                  - logger.log: API is connected!
                  - lambda: "id(api_connection) = true;"
                  - switch.turn_on: ble_jk
                  - esp32_ble_tracker.start_scan:
                      continuous: true
          else:
            - if:
                condition:
                  not:
                    api.connected:
                then:
                  # just disconnected now
                  - logger.log: API is disconnected!
                  - lambda: "id(api_connection) = false;"
                  - switch.turn_off: ble_jk
                  - esp32_ble_tracker.stop_scan:

      - lambda: |-

          if (!id(api_connection) || isnan(id(powermeter0).state)) {
            //goal: Only use solar power, 0W to or from battery. Disable below 50W because of bad efficency.
            id(operationMode) = 1;
            return;
          }


          if (id(userOpMode).state == "useBattery") {
            //use powermeter for demand
            id(operationMode) = 3;
          } else if (id(userOpMode).state == "usePV") {
            //PV -> demand, but charge when PV > power consumption
            id(operationMode) = 2;
          } else {
            //charge Battery only
            id(operationMode) = 4;
          }

      - lambda: |-

          if (id(operationMode) == 0 || id(operationMode) == 1 || id(operationMode) == 4) {
            auto prevLatency = id(soyo_latency).state;
            if (prevLatency > 3000) {
              auto l = id(soyo_latency).make_call();
              l.set_value(2050);
              l.perform();
            }

            if (id(operationMode) == 0) {
              auto b = id(soyo_buffer).make_call();
              b.set_value(2);
              b.perform();
            }
          }
          else {
            auto prevLatency = id(soyo_latency).state;
            if (prevLatency < 3000) {
              auto l = id(soyo_latency).make_call();
              l.set_value(4550);
              l.perform();
            }

            auto prevBuffer = id(soyo_buffer).state;
            if (prevBuffer == 2) {
              auto b = id(soyo_buffer).make_call();
              b.set_value(-2);
              b.perform();
            }
          }

          if (id(min_batt_temp).state > 15 && id(max_batt_temp).state < 39) {
            id(maxChargeW) = 1500;
          }
          else if (id(min_batt_temp).state < 5 || id(max_batt_temp).state > 45) {
            id(maxChargeW) = 6;
          }
          else if (id(min_batt_temp).state < 6) {
            id(maxChargeW) = 100;
          }
          else if (id(min_batt_temp).state < 7) {
            id(maxChargeW) = 150;
          }
          else if (id(min_batt_temp).state < 8 || id(max_batt_temp).state > 43) {
            id(maxChargeW) = 200;
          }
          else if (id(min_batt_temp).state < 9) {
            id(maxChargeW) = 300;
          }
          else if (id(min_batt_temp).state < 10) {
            id(maxChargeW) = 400;
          }
          else if (id(min_batt_temp).state < 11 || id(max_batt_temp).state > 40) {
            id(maxChargeW) = 650;
          }
          else if (id(min_batt_temp).state < 12) {
            id(maxChargeW) = 750;
          }
          else if (id(min_batt_temp).state < 13) {
            id(maxChargeW) = 900;
          }
          else if (id(min_batt_temp).state < 14) {
            id(maxChargeW) = 1050;
          }
          else {
            id(maxChargeW) = 1300;
          }

          if (id(maxCellVolt).raw_state > 4.12 && id(maxChargeW) > id(maxChargeWReduction)) {
            id(maxChargeWReduction) += 100;
          }
          else if (id(maxCellVolt).raw_state < 4.1 && id(maxChargeWReduction) > 0) {
            id(maxChargeWReduction) -= 25;
          }
          
          id(maxChargeW) -= id(maxChargeWReduction);
          


      - lambda: |-
          if (id(soyo_operation_mode).state == "PV") {
            id(max_demand) = 1120;
          } else {
            id(max_demand) = 920;
          }

          int md = id(soyo_max_demand).state;

          if ((md == 920.0 || md == 1120.0) && md != id(max_demand)) {
            auto numberF = id(soyo_max_demand).make_call();
            numberF.set_value(id(max_demand));
            numberF.perform();
          }

#      - lambda: |-
#          ESP_LOGW("CPU", "CPU freq: %d", esp_clk_cpu_freq());



#display settings of the soyo to set automatically:
  - interval: 101s
    startup_delay: 19s
    then:
      - if:
          condition:
            - lambda: "return { id(soyo_output_limit).state != 900.0 };"
          then:
            - number.set:
                id: soyo_output_limit
                value: 900
      - if:
          condition:
            - lambda: "return { id(soyo_start_delay).state != 3.0 };"
          then:
            - number.set:
                id: soyo_start_delay
                value: 3
      - if:
          condition:
            - lambda: "return { id(soyo_operation_mode).state == \"Battery Constant Power\" };"
          then:
            - select.set:
                id: soyo_operation_select
                option: "Battery Limit"

  - interval: 43s
    startup_delay: 3s
    then:
      - switch.turn_on: ntc_vcc
      - component.update: adc1
      - component.update: adc2
      - switch.turn_off: ntc_vcc

  - interval: 50ms
    startup_delay: 1s
    then:
      - component.update: mpptSensorOW
      - component.update: mpptSensor
      - component.update: soyoSensor


esp32_ble_tracker:
  scan_parameters:
    interval: 640ms
    continuous: false
    active: false
  on_ble_advertise:
    then:
      - lambda: |-
          if (x.get_name().rfind("JK-", 0) == 0) {
            ESP_LOGI("ble_adv", "New JK-BMS found");
            ESP_LOGI("ble_adv", "  Name: %s", x.get_name().c_str());
            ESP_LOGI("ble_adv", "  MAC address: %s", x.address_str().c_str());
            ESP_LOGD("ble_adv", "  Advertised service UUIDs:");
            for (auto uuid : x.get_service_uuids()) {
              ESP_LOGD("ble_adv", "    - %s", uuid.to_string().c_str());
            }
          }

ble_client:
  - mac_address: ${mac_address}
    id: client0

jk_bms_ble:
  - ble_client_id: client0
    protocol_version: ${protocol_version}
    throttle: 0s
    id: bms0

output:
  - platform: ledc
    pin: 
      number: ${pinMpptCtrl}
    id: mpptVoltLimit
    min_power: 0.55
    max_power: 0.75
    frequency: 1200Hz
    channel: 0

  - platform: ledc
    pin: 
      number: ${pinBattFan}
    id: battFanPwm
    inverted: true
    frequency: 500Hz
    min_power: 0.2
    zero_means_zero: true
    channel: 2

  - platform: ledc
    pin: 
      number: ${pinBattHeater}
    id: battHeaterPwm
    inverted: true
    frequency: 50Hz
    channel: 4
    max_power: 0.95

fan:
  - platform: speed
    output: mpptVoltLimit
    id: mpptVoltLimitControl
    name: "Charger Voltage Limit"
    restore_mode: RESTORE_DEFAULT_ON

  - platform: speed
    output: battFanPwm
    id: battFan
    name: batteryFan

  - platform: speed
    output: battHeaterPwm
    id: battHeater
    name: batteryHeater
    on_turn_on:
      - lambda: |-
          auto c=id(battFan).turn_on();
          c.set_speed(id(battHeater).speed);
          c.perform();

    on_turn_off:
      - delay: 2s
      - lambda: |-
          auto c=id(battFan).turn_off();
          c.perform();

    on_speed_set:
      - delay: 1s
      - lambda: |-
          auto c=id(battFan).turn_on();
          c.set_speed(x);
          c.perform();

i2c:
  sda: ${pinSda}
  scl: ${pinScl}
  frequency: 333kHz
  timeout: 5ms

ads1115:
  - address: 0x4A

uart:
  - id: uart_powerd
    baud_rate: 4800
    tx_pin: ${pinSoyoTx}
    rx_pin: ${pinSoyoRx}
  - id: uart_display
    baud_rate: 9600
    tx_pin: ${pinSoyoDispTx}
    rx_pin: ${pinSoyoDispRx}

soyosource_modbus:
  - id: modbus1
    uart_id: uart_powerd

    # Optional settings
    #
    # The name is used as prefix for some log messages and should
    # help to distinguish between different instances/devices
    name: garage_inverter

soyosource_virtual_meter:
  - id: virtualmeter0
    soyosource_modbus_id: modbus1

    # The state of this sensor (instantaneous power in watt) is used as source
    power_id: powermeter_with_fallback

    # Optional settings
    power_sensor_inactivity_timeout: 20s
    power_demand_calculation: NEGATIVE_MEASUREMENTS_REQUIRED
    min_power_demand: 0
    max_power_demand: 1120
    # Split/distribute the power demand if you have multiple inverters attached to the same RS485 bus
    power_demand_divider: 1
    # A positive buffer value (10) tries to avoid exporting power to the grid (demand - 10 watts)
    # A negative buffer value (-10) exports power to the grid (demand + 10 watts)
    buffer: 0
    zero_output_on_min_power_demand: true
    max_power_sensor_latency_ms: 4550

    # The operation_status_id sensor is expected here. Passing the operation_status won't work
    # The state is used to suspend the limiter if the operation status of the inverter isn't 0x0 (normal)
    # operation_status_id: operation_status_id0
    update_interval: never

soyosource_display:
  - id: soyo_display
    uart_id: uart_display
    protocol_version: SOYOSOURCE_DISPLAY_VERSION
    update_interval: 5s


binary_sensor:
  - platform: jk_bms_ble
    balancing:
      name: "${name} balancing"
    online_status:
      name: "${name} online status"
  - platform: soyosource_display
    limiter_connected:
      name: "${name_soyo} limiter connected"

  - platform: gpio
    pin:
      number: ${pinGarageClosedL}
      inverted: true
      mode:
        input: true
    id: garage_is_closed
    on_press:
      then:
        - cover.template.publish:
            id: garage_cover
            position: !lambda 'return 0.0;'
#            current_operation: IDLE
        - lambda: id(garageDoorState) = 0;
    on_release:
      then:
        - cover.template.publish:
            id: garage_cover
            position: 0.5
#            current_operation: OPENING

  - platform: gpio
    pin:
      number: ${pinGarageOpenedH}
      inverted: false
      mode:
        input: true
    id: garage_is_open
    on_press:
      then:
        - cover.template.publish:
            id: garage_cover
            position: !lambda 'return 1.0;'
#            current_operation: IDLE
        - lambda: id(garageDoorState) = 1;
    on_release:
      then:
        - cover.template.publish:
            id: garage_cover
            position: 0.5
#            current_operation: CLOSING

cover:
  - platform: template
    id: garage_cover
    name: "Garagentor"
    has_position: true
    lambda: |-
      if (id(garage_is_closed).state) {
        return 0.0;
      }
      else if (id(garage_is_open).state) {
        return 1.0;
      }
      else {
        return 0.5;
      }
    open_action:
      - if:
          condition:
            - lambda: 'return (!id(garage_is_closed).state && !id(garage_is_open).state && id(garageDoorState) == 0);'
          then:
            # closing
            - switch.turn_on: garage_toggle_switch
            - delay: 500ms
            # stopping:
            - switch.turn_on: garage_toggle_switch
            - delay: 500ms
            # opening:
            - switch.turn_on: garage_toggle_switch
          else:
            - switch.turn_on: garage_toggle_switch
    close_action:
      - if:
          condition:
            - lambda: 'return (!id(garage_is_closed).state && !id(garage_is_open).state && id(garageDoorState) == 1);'
          then:
            # opening:
            - switch.turn_on: garage_toggle_switch
            - delay: 500ms
            # stopping:
            - switch.turn_on: garage_toggle_switch
            - delay: 500ms
            # closing:
            - switch.turn_on: garage_toggle_switch
          else:
            - switch.turn_on: garage_toggle_switch
    stop_action:
      - switch.turn_on: garage_toggle_switch
    position_action:
      - lambda: |-
          if (pos < 0.1) {
            auto call = id(garage_cover).make_call();
            call.set_command_close();
            call.perform();
          }
          else if (pos > 0.9) {
            auto call = id(garage_cover).make_call();
            call.set_command_open();
            call.perform();
          }
          else {
            id(garage_tilt_switch).turn_on();
          }

button:
  - platform: soyosource_display
    restart:
      name: "${name_soyo} restart"
  - platform: jk_bms_ble
    retrieve_settings:
      name: "${name} retrieve settings"
    retrieve_device_info:
      name: "${name} retrieve device info"


number:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    manual_power_demand:
      name: "${name_soyo} manual power demand"
      max_value: 1300
    max_power_demand:
      name: "${name_soyo} max power demand"
      id: soyo_max_demand
      initial_value: 920
      max_value: 1120
      restore_value: false
    buffer:
      name: "${name_soyo} buffer"
      id: soyo_buffer
      initial_value: 0
      restore_value: true
    max_power_sensor_latency_ms:
      name: "${name_soyo} sensor_latency"
      id: soyo_latency
      initial_value: 4550
      restore_value: false

  - platform: soyosource_display
    start_voltage:
      name: "${name_soyo} start voltage"
    shutdown_voltage:
      name: "${name_soyo} shutdown voltage"
    # Maximum output power in limiter mode / Output power in constant power mode
    output_power_limit:
      name: "${name_soyo} output power limit"
      id: soyo_output_limit
    start_delay:
      name: "${name_soyo} start delay"
      id: soyo_start_delay

  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    balance_trigger_voltage:
      name: "${name} balance trigger voltage"
    total_battery_capacity:
      name: "${name} total battery capacity"
    cell_voltage_overvoltage_protection:
      name: "${name} cell voltage overvoltage protection"
    cell_voltage_overvoltage_recovery:
      name: "${name} cell voltage overvoltage recovery"
    cell_voltage_undervoltage_protection:
      name: "${name} cell voltage undervoltage protection"
    cell_voltage_undervoltage_recovery:
      name: "${name} cell voltage undervoltage recovery"
    balance_starting_voltage:
      name: "${name} balance starting voltage"
    power_off_voltage:
      name: "${name} power off voltage"
    max_balance_current:
      name: "${name} max balance current"
    max_charge_current:
      name: "${name} max charge current"
    max_discharge_current:
      name: "${name} max discharge current"

select:
  - platform: soyosource_display
    operation_mode:
      name: "${name_soyo} operation mode"
      id: soyo_operation_select
      optionsmap:
        1: "PV"
        2: "Battery Constant Power"
        16: "Battery Limit"

  - platform: template
    name: "operationMode"
    id: userOpMode
    optimistic: true
    initial_option: usePV
    restore_value: true
    options: 
      - chargeOnly
      - usePV
      - useBattery

sensor:
  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal %"
    update_interval: 120s
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: "diagnostic"

  - platform: dht
    pin: ${pinDHT}
    temperature:
      name: "Garage Temperatur"
      id: garage_temp
    humidity:
      name: "Garage Feuchtigkeit"
      id: garage_humid
    update_interval: 120s

  - platform: ina226
    address: 0x40
    update_interval: never
    id: soyoSensor
    shunt_resistance: 0.0015 ohm
    max_current: 50A
    adc_time:
      voltage: 140us
      current: 588us
    adc_averaging: 64
    current:
      #name: "Inverter amps"
      id: inverter_amps
      filters:
        - exponential_moving_average:
           send_every: 5
           alpha: 0.079
        - offset: 0.001526
      on_value:
        then:
          - component.update: soyo_power
          - component.update: powermeter_with_fallback
          - component.update: charging_power
          - component.update: discharging_power
          - component.update: combinedAmps

  - platform: ina226
    address: 0x41
    shunt_resistance: 0.0015 ohm
    max_current: 50A
    adc_time:
      voltage: 140us
      current: 588us
    adc_averaging: 64
    update_interval: never
    id: mpptSensor
    current:
      id: charging_amps
      #name: cargingAmps
      filters:
        - exponential_moving_average:
           send_every: 5
      on_value:
        then:
          - component.update: solar_power_only

  - platform: ina226
    address: 0x44
    shunt_resistance: 0.0015 ohm
    max_current: 50A
    adc_time:
      voltage: 140us
      current: 588us
    adc_averaging: 64
    update_interval: never
    id: mpptSensorOW
    current:
      id: charging_ampsOW
      filters:
        - exponential_moving_average:
           send_every: 5
      on_value:
        then:
          - component.update: solar_power_onlyOW
    bus_voltage:
      id: batt_voltage
      filters:
        - exponential_moving_average:
           send_every: 5
        - calibrate_linear:
          - 0 -> 0
          - 28.68 -> 60
      on_value_range:
        - above: ${maxBattVoltage}
          then:
            - lambda: |-
               auto c=id(mpptVoltLimitControl).turn_on();
               c.set_speed(100);
               c.perform();

# import smartmeter reading from homeassistant
#   # requires the "api" component see above
  - platform: homeassistant
    id: powermeter0
    entity_id: sensor.power_consumption
    on_value:
      then:
        - component.update: powermeter_with_fallback

  - platform: template
    id: powermeter_with_fallback
    update_interval: 5s #minimal intervall
    internal: true
    unit_of_measurement: W
    lambda: |-

      auto solar_power = id(solar_power_only).state + id(solar_power_onlyOW).state;
      auto demand = solar_power - id(soyo_power).raw_state;
      auto chargingW = demand;
      auto max_inverter_power = id(max_demand) - id(soyo_power_demand).state;

      switch (id(operationMode)) {
        case 1:
          //no api connection, only solar above 60W, else charging

          if (solar_power < 70) {
            demand = -20; //get's to 0W demand slowly
          }
          break;
        case 2:
          if (solar_power > 70) {
            if (demand > id(powermeter0).state) {
              demand = id(powermeter0).state;
            }
          }
          else {
            demand = -20; //get's to 0W demand slowly
          }
          break;
        case 3:
          demand = id(powermeter0).state;
          break;
        case 4:
          demand = -100; //off / only charging
          break;
        case 0:
        default:
          //protect battery, no charging
          if (solar_power < 8) {
            demand = -7;
          }
      }

      //make sure demand number cannot be higher than possible inverter output
      if (demand > max_inverter_power) {
        demand = max_inverter_power;
      }

      if (chargingW - demand > id(maxChargeW)) {
        return chargingW - id(maxChargeW);
      }
      return demand;


  - platform: template
    id: soyo_power
    name: "soyo power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    lambda: |-
      return id(batt_voltage).state * id(inverter_amps).state;
    update_interval: 5s
    filters:
      - throttle_average: 5s

  - platform: template
    id: solar_power_only
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    lambda: |-
      return (isnan(id(batt_voltage).state) ? 0 : id(batt_voltage).state) 
        * (isnan(id(charging_amps).state) ? 0 : id(charging_amps).state);
    update_interval: 5s
    on_value:
      then:
        - component.update: solar_power_positive

  - platform: template
    id: solar_power_onlyOW
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    lambda: |-
      return (isnan(id(batt_voltage).state) ? 0 : id(batt_voltage).state)
        * (isnan(id(charging_ampsOW).state) ? 0 : id(charging_ampsOW).state);
    update_interval: 5s
    on_value:
      then:
        - component.update: solar_power_positiveOW
          #workaround for too high standby consumption of mppt. Value is changed back by the other control loop in overchargingPower.
        - lambda: |-
            if (x < -1.1) {
              auto c = id(mpptVoltLimitControl).turn_on();
              c.set_speed(100);
              c.perform();
            }

  - platform: template
    id: solar_power_positive
    lambda: return id(solar_power_only).state;
    filters:
      - clamp:
          min_value: 0
    update_interval: never

  - platform: template
    id: solar_power_positiveOW
    lambda: return id(solar_power_onlyOW).state;
    filters:    
      - clamp:  
          min_value: 0
    update_interval: never

  - platform: template
    id: charging_power
    unit_of_measurement: W
    lambda: |-
      auto w = id(solar_power_only).raw_state + id(solar_power_onlyOW).state - id(soyo_power).raw_state;
      return w < 0 ? 0 : w;
    update_interval: 5s

  - platform: template
    id: discharging_power
    unit_of_measurement: W
    lambda: |-
       auto w = id(soyo_power).raw_state - (id(solar_power_only).raw_state + id(solar_power_onlyOW).state);
       return w < 0 ? 0 : w;
    update_interval: 5s

  - platform: template
    id: overchargingPower
    unit_of_measurement: W
    update_interval: 3s
    lambda: |-
      if (id(battHeater).state && (isnan(id(min_batt_temp).state) || id(min_batt_temp).state > 15 || id(max_batt_temp).state >= 22)) {
        auto h = id(battHeater).turn_off();
        h.set_speed(0);
        h.perform();
      }

      //fallback if sensors aren't working. OWpower == exactly 0 is basically NaN.
      if (isnan(id(batt_voltage).state) || id(solar_power_onlyOW).state == 0) {
        auto c = id(mpptVoltLimitControl).turn_on();
        c.set_speed(100);
        c.perform();
      }

      auto w = id(charging_power).state - id(maxChargeW);
      if (w > 40) {
        if (id(min_batt_temp).state < 15 && id(max_batt_temp).state < 22) {
          auto h = id(battHeater).turn_on();
          auto hs = id(battHeater).speed;
          h.set_speed(hs + 10);
          h.perform();
          if (hs < 80 && w < 100) {
            return 5;
          }
        }
        return w;
      }
      if (!isnan(id(powermeter0).state) && id(powermeter0).state < -50 && w > -50) {
        auto power = id(powermeter0).state * -1;
        if (id(min_batt_temp).state < 15 && id(max_batt_temp).state < 22) {
          auto h = id(battHeater).turn_on();
          auto hs = id(battHeater).speed;
          if (power > 100) {
            h.set_speed(hs + 30);
          } else {
            h.set_speed(hs + 10);
          }
          h.perform();
          return power -200;
        }
        return power -150;
      }
      else if (id(battHeater).state && (isnan(id(powermeter0).state) && w < -100 || id(powermeter0).state > -10)) {
        auto h = id(battHeater).turn_on();
        auto hs = id(battHeater).speed;
        if (hs <= 10) {
          auto heater = id(battHeater).turn_off();
          heater.perform();
        }
        else {
          h.set_speed(hs - 10);
          h.perform();
        }
      }
      return 0;
    on_value:
      then:
        - lambda: |-
            auto c = id(mpptVoltLimitControl).turn_on();
            auto speed = id(mpptVoltLimitControl).speed;
            auto volt = id(batt_voltage).state;
            auto OWpower = id(solar_power_onlyOW).state;

            if (speed < 100 && (OWpower > 1 && (volt > ${maxBattVoltage} -0.1 || x > 60))) {
              if (x > 150 || volt > ${maxBattVoltage}) {
                c.set_speed(speed + 15);
              }
              else {
                c.set_speed(speed + 2);
              }
              c.perform();
            }
            else if (volt < ${maxBattVoltage} -0.2 && x < 5) {
              c.set_speed(speed - 1);
              c.perform();
            }


  - platform: template
    id: batt_voltage_avg
    update_interval: 60s
    lambda: return id(batt_voltage).state;
    filters:
      - sliding_window_moving_average:
          window_size: 6
          send_every: 1
    on_value_range:
        - above: 53.1
          then:
            - number.set:
                id: soyo_buffer
                value: -10
        - below: 53
          then:
            - number.set:
                id: soyo_buffer
                value: -2
        - above: 44.4
          then:
            - number.set:
                id: soyo_max_demand
                value: !lambda |-
                  return id(max_demand);
        - below: 43.8
          then:
            - number.set:
                id: soyo_max_demand
                value: 200

  - platform: template
    id: combinedAmps
    lambda: |-
       auto a = (isnan(id(charging_amps).state) ? 0 : id(charging_amps).state)
                + (isnan(id(charging_ampsOW).state) ? 0 : id(charging_ampsOW).state)
                - (isnan(id(inverter_amps).state) ? 0 : id(inverter_amps).state);
       if (a > 2) {
         return a * 0.99; // reduce SOC drift by efficency loss of battery
       }
       return a;
    update_interval: 1s

  - platform: integration
    id: coulomb_counter
    sensor: combinedAmps
    accuracy_decimals: 0
    time_unit: s
    restore: true
    filters:
      - throttle: 10s
    on_value:
      then:
        - lambda: if (x > 1) { id(coulomb_counter).reset(); }

  - platform: template
    name: PV Batt SOC
    id: batt_soc
    lambda: return id(coulomb_counter).state;
    update_interval: 180s
    unit_of_measurement: '%'
    accuracy_decimals: 0
    device_class: battery
    state_class: measurement
    filters:
      - calibrate_linear:
          - -248400 -> 0 #69Ah *60 *60 -> As
          - 0 -> 100
      - clamp:
          min_value: 0
          max_value: 100


  - platform: template
    id: slow_system_power
    lambda: return id(system_power).state;
    update_interval: 1min
    filters: 
      - exponential_moving_average:
          send_every: 20
    on_value_range:
      - below: 20
        above: -20
        then:
          - lambda: |-
              auto volt = id(batt_voltage_avg).state;
              int maxC = 248400;

              if(volt < 43.5) {
                //0%
                id(coulomb_counter).publish_and_save(maxC * -1);
              }
              else if(volt > ${maxBattVoltage} - 0.12) {
                //100%
                id(coulomb_counter).publish_and_save(0);
              }


# throttled for HA:
  - platform: template
    id: system_power
    name: "Garage System Power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 5s
    lambda: return id(solar_power_only).raw_state + id(solar_power_onlyOW).state - id(soyo_power).raw_state;

  - platform: template
    name: "solarstrom power"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    entity_category: diagnostic
    accuracy_decimals: 2
    icon: mdi:solar-power-variant
    lambda: return id(solar_power_only).state;
    update_interval: 5s

  - platform: template
    name: "solarstrom powerOW"
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    entity_category: diagnostic
    accuracy_decimals: 2
    icon: mdi:solar-power-variant
    lambda: return id(solar_power_onlyOW).state;
    update_interval: 5s

  - platform: template
    name: "Batt Volt"
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    lambda: return id(batt_voltage).state;
    update_interval: 5s

  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    power_demand:
      name: "${name_soyo} power demand"
      id: soyo_power_demand
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      entity_category: diagnostic

  - platform: total_daily_energy
    name: "${name} charging energy today"
    icon: mdi:counter
    power_id: charging_power
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - throttle: 120s
      - multiply: 0.925 #dc -> ac conversion 92,5%
      - multiply: 0.001 #Wh -> kWh

  - platform: total_daily_energy
    name: "${name} discharging energy today"
    icon: mdi:counter
    power_id: discharging_power
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - throttle: 120s
      - multiply: 0.925 #dc -> ac conversion 92,5%
      - multiply: 0.001 #Wh -> kWh

  - platform: total_daily_energy
    name: "solarstrom energy"
    id: solar_energy_today
    icon: mdi:counter
    power_id: solar_power_positive
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - throttle: 120s
      - multiply: 0.925 #dc -> ac conversion 92,5%
      - multiply: 0.001 #Wh -> kWh

  - platform: total_daily_energy
    name: "solarstrom energy OW"
    id: solar_energy_todayOW
    icon: mdi:counter
    power_id: solar_power_positiveOW
    accuracy_decimals: 3
    unit_of_measurement: kWh
    restore: true
    filters:
      - throttle: 120s
      - multiply: 0.925 #dc -> ac conversion 92,5%
      - multiply: 0.001 #Wh -> kWh

  - platform: ads1115
    multiplexer: 'A0_GND'
    gain: 4.096
    id: adc1
    update_interval: never

  - platform: ads1115
    multiplexer: 'A1_GND'
    gain: 4.096
    id: adc2
    update_interval: never

  - platform: resistance
    id: resistance_sensor_1
    sensor: adc1
    configuration: DOWNSTREAM
    resistor: 5.75kOhm
    reference_voltage: 3.2V
  - platform: resistance
    id: resistance_sensor_2
    sensor: adc2
    configuration: DOWNSTREAM
    resistor: 5.75kOhm
    reference_voltage: 3.2V

  - platform: ntc
    sensor: resistance_sensor_1
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    name: "Batt Temp 3"
    id: batt_temp3
    filters:
      - sliding_window_moving_average:
          window_size: 7
          send_every: 3
  - platform: ntc
    sensor: resistance_sensor_2
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    name: "Batt Temp 4"
    id: batt_temp4
    filters:
      - sliding_window_moving_average:
          window_size: 7
          send_every: 3

  - platform: combination
    type: min
    id: min_batt_temp
    sources:
      - source: batt_temp1
      - source: batt_temp2
      - source: batt_temp3
      - source: batt_temp4

  - platform: combination
    type: max
    id: max_batt_temp
    sources:
      - source: batt_temp1
      - source: batt_temp2
      - source: batt_temp3
      - source: batt_temp4
    on_value_range:
      - above: 35
        then:
          - fan.turn_on:
              id: battFan
              speed: 100
      - below: 32
        then:
          - fan.turn_off: battFan


  - platform: soyosource_display
    error_bitmask:
      name: "${name_soyo} error bitmask"
#    operation_status_id:
#      name: "${name_soyo} operation status id"
#      id: operation_status_id0
    battery_voltage:
      name: "${name_soyo} battery voltage"
      id: soyo_batt_voltage
      filters:
        - throttle: 10s
    battery_current:
      name: "${name_soyo} battery current"
      id: soyo_batt_current
      filters:
        - throttle: 10s
        - multiply: 0.933 #calibrate too high values
    battery_power:
      name: "${name_soyo} battery power"
      filters:
        - throttle: 10s
    ac_voltage:
      name: "${name_soyo} ac voltage"
      filters:
        - throttle: 30s
    ac_frequency:
      name: "${name_soyo} ac frequency"
      filters:
        - throttle: 120s
    temperature:
      name: "${name_soyo} temperature"
      filters:
        - throttle: 30s
  
  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    power:
      name: "${name} power"
      id: "jk_bms_power"
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      entity_category: diagnostic
      filters:
        - throttle_average: 10s

    min_cell_voltage:
      name: "${name} min cell voltage"
      filters:
      - throttle: 10s
    max_cell_voltage:
      name: "${name} max cell voltage"
      id: maxCellVolt
      on_raw_value:
        then:
          - lambda: |-
              if (x > 4.15) {
                auto c=id(mpptVoltLimitControl).turn_on();
                c.set_speed(100);
                c.perform();
              }

      filters:
      - throttle: 10s
    min_voltage_cell:
      name: "${name} min voltage cell"
      filters:
      - throttle: 10s
    max_voltage_cell:
      name: "${name} max voltage cell"
      filters:
      - throttle: 10s
    delta_cell_voltage:
      name: "${name} delta cell voltage"
      filters:
      - throttle: 10s
    average_cell_voltage:
      name: "${name} average cell voltage"
      filters:
      - throttle: 10s
    cell_voltage_1:
      name: "${name} cell voltage 1"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_2:
      name: "${name} cell voltage 2"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_3:
      name: "${name} cell voltage 3"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_4:
      name: "${name} cell voltage 4"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_5:
      name: "${name} cell voltage 5"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_6:
      name: "${name} cell voltage 6"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_7:
      name: "${name} cell voltage 7"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_8:
      name: "${name} cell voltage 8"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_9:
      name: "${name} cell voltage 9"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_10:
      name: "${name} cell voltage 10"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_11:
      name: "${name} cell voltage 11"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_12:
      name: "${name} cell voltage 12"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    cell_voltage_13:
      name: "${name} cell voltage 13"
      icon: mdi:battery-charging
      filters:
      - throttle: 10s
    power_tube_temperature:
      name: "${name} BMS temperature"
      filters:
      - throttle: 10s
    temperature_sensor_1:
      id: batt_temp1
      name: "${name} temperature sensor 1"
      filters:
      - throttle: 10s
    temperature_sensor_2:
      id: batt_temp2
      name: "${name} temperature sensor 2"
      filters:
      - throttle: 10s
    total_voltage:
      name: "${name} total voltage"
      id: jk_bms_total_voltage
      filters:
        - throttle: 10s
    current:
      name: "${name} current"
      filters:
        - throttle: 10s
    charging_cycles:
      name: "${name} charging cycles"
      filters:
        - throttle: 120s
    errors_bitmask:
      name: "${name} errors bitmask"
    state_of_charge:
      name: "${name} state of charge"
    balancing_current:
      name: "${name} balancing current"
      filters:
      - throttle: 5s

switch:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    manual_mode:
      name: "${name_soyo} manual mode"
      restore_mode: RESTORE_DEFAULT_ON
    emergency_power_off:
      name: "${name_soyo} emergency power off"
      restore_mode: RESTORE_DEFAULT_OFF

  - platform: gpio
    pin: ${pinGarageTiltL}
    name: "Garage lüften"
    id: garage_tilt_switch
    inverted: true 
    restore_mode: ALWAYS_OFF
    interlock: [garage_toggle_switch]
    on_turn_on:
    - delay: 200ms
    - switch.turn_off: garage_tilt_switch
    - delay: 400ms

  - platform: gpio
    pin: ${pinGarageToggleL}
    name: "Garagentor auf/zu"
    id: garage_toggle_switch
    inverted: true
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [garage_tilt_switch]
    on_turn_on:
    - delay: 200ms
    - switch.turn_off: garage_toggle_switch
    - delay: 400ms

  - platform: gpio
    pin: ${pinNtcVccH}
    id: ntc_vcc
    internal: true

  - platform: jk_bms_ble
    charging:
      name: "${name} charging"
    discharging:
      name: "${name} discharging"
    balancer:
      name: "${name} balancer"

  - platform: ble_client
    ble_client_id: client0
    id: ble_jk
    name: "${name} enable bluetooth connection"

  - platform: restart
    name: "reboot"


text_sensor:
  - platform: soyosource_virtual_meter
    soyosource_virtual_meter_id: virtualmeter0
    operation_mode:
      name: "${name_soyo} limiter operation mode"
  - platform: soyosource_display
    errors:
      name: "${name_soyo} errors"
    operation_mode:
      name: "${name_soyo} operation mode"
      id: soyo_operation_mode
    operation_status:
      name: "${name_soyo} operation status"

  - platform: jk_bms_ble
    errors:
      name: "${name} errors"
    total_runtime_formatted:
      name: "${name} total runtime formatted"
        #  - platform: debug
        #    device:
        #      name: "Device Info"
        #    reset_reason:
        #      name: "Reset Reason"
#  - platform: ble_scanner
#    name: "BLE Devices Scanner"
